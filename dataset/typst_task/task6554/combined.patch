diff --git a/crates/typst/src/foundations/str.rs b/crates/typst/src/foundations/str.rs
index d90b6f206..3f63d7c34 100644
--- a/crates/typst/src/foundations/str.rs
+++ b/crates/typst/src/foundations/str.rs
@@ -176,26 +176,132 @@ impl Str {
         self.0.len()
     }
 
-    /// Extracts the first grapheme cluster of the string.
-    /// Fails with an error if the string is empty.
+    /// Extracts grapheme clusters from the start of the string.
+    ///
+    /// Supports indexed access, multi-character extraction, whitespace
+    /// skipping, pattern matching, safe fallbacks, and default values.
     #[func]
-    pub fn first(&self) -> StrResult<Str> {
-        self.0
-            .graphemes(true)
-            .next()
-            .map(Into::into)
-            .ok_or_else(string_is_empty)
+    pub fn first(
+        &self,
+        /// The character index to extract (0-based). If omitted, extracts the first character.
+        #[default]
+        index: Option<usize>,
+        /// A default value to return if no characters can be extracted.
+        #[named]
+        default: Option<Str>,
+        /// Pattern to match: "alpha", "numeric", "alphanumeric", "uppercase", "lowercase", "whitespace".
+        #[named]
+        pattern: Option<Str>,
+        /// Whether to skip leading whitespace before extraction.
+        #[named]
+        #[default(false)]
+        skip_whitespace: bool,
+        /// Whether to return none instead of an error when nothing can be extracted.
+        #[named]
+        #[default(false)]
+        safe: bool,
+        /// Number of consecutive graphemes to concatenate starting at the resolved index.
+        #[named]
+        #[default(1)]
+        repeat: usize,
+        /// Number of graphemes to return as an array starting at the resolved index.
+        #[named]
+        count: Option<usize>,
+        /// Characters to strip from the start before selection.
+        #[named]
+        #[default]
+        strip: Option<Str>,
+        /// Whether to operate on graphemes (default) or words.
+        #[named]
+        #[default]
+        unit: Option<Str>,
+        /// Transform the selected segment's casing.
+        #[named]
+        #[default]
+        case: Option<Str>,
+    ) -> StrResult<Value> {
+        if let Some(case_value) = case.as_ref() {
+            validate_case(case_value)?;
+        }
+
+        let value = extract(
+            self,
+            index,
+            default,
+            pattern,
+            skip_whitespace,
+            safe,
+            repeat,
+            count,
+            strip.as_ref(),
+            unit.as_ref(),
+            ExtractDirection::First,
+        )?;
+        apply_case_value(value, case)
     }
 
-    /// Extracts the last grapheme cluster of the string.
-    /// Fails with an error if the string is empty.
+    /// Extracts grapheme clusters from the end of the string.
+    ///
+    /// Supports indexed access, multi-character extraction, whitespace
+    /// skipping, pattern matching, safe fallbacks, and default values.
     #[func]
-    pub fn last(&self) -> StrResult<Str> {
-        self.0
-            .graphemes(true)
-            .next_back()
-            .map(Into::into)
-            .ok_or_else(string_is_empty)
+    pub fn last(
+        &self,
+        /// The character index from the end to extract (0-based). If omitted, extracts the last character.
+        #[default]
+        index: Option<usize>,
+        /// A default value to return if no characters can be extracted.
+        #[named]
+        default: Option<Str>,
+        /// Pattern to match: "alpha", "numeric", "alphanumeric", "uppercase", "lowercase", "whitespace".
+        #[named]
+        pattern: Option<Str>,
+        /// Whether to skip trailing whitespace before extraction.
+        #[named]
+        #[default(false)]
+        skip_whitespace: bool,
+        /// Whether to return none instead of an error when nothing can be extracted.
+        #[named]
+        #[default(false)]
+        safe: bool,
+        /// Number of consecutive graphemes to concatenate ending at the resolved index.
+        #[named]
+        #[default(1)]
+        repeat: usize,
+        /// Number of graphemes to return as an array ending at the resolved index.
+        #[named]
+        count: Option<usize>,
+        /// Characters to strip from the end before selection.
+        #[named]
+        #[default]
+        strip: Option<Str>,
+        /// Whether to operate on graphemes (default) or words.
+        #[named]
+        #[default]
+        unit: Option<Str>,
+        /// Transform the selected segment's casing.
+        #[named]
+        #[default]
+        case: Option<Str>,
+    ) -> StrResult<Value> {
+        if let Some(case_value) = case.as_ref() {
+            validate_case(case_value)?;
+        }
+
+        let value = extract(
+            self,
+            index,
+            default,
+            pattern,
+            skip_whitespace,
+            safe,
+            repeat,
+            count,
+            strip.as_ref(),
+            unit.as_ref(),
+            ExtractDirection::Last,
+        )?;
+        apply_case_value(value, case)
     }
 
     /// Extracts the first grapheme cluster after the specified index. Returns
@@ -604,6 +710,322 @@ impl Str {
     }
 }
 
+#[derive(Clone, Copy)]
+enum ExtractDirection {
+    First,
+    Last,
+}
+
+fn extract(
+    string: &Str,
+    index: Option<usize>,
+    default: Option<Str>,
+    pattern: Option<Str>,
+    skip_whitespace: bool,
+    safe: bool,
+    repeat: usize,
+    count: Option<usize>,
+    strip: Option<&Str>,
+    unit: Option<&Str>,
+    direction: ExtractDirection,
+) -> StrResult<Value> {
+    if repeat == 0 {
+        return Err(eco_format!("repeat must be at least 1"));
+    }
+
+    if let Some(n) = count {
+        if n == 0 {
+            return Err(eco_format!("count must be at least 1"));
+        }
+    }
+
+    let unit = selection_unit(unit)?;
+    if matches!(unit, SelectionUnit::Word) && pattern.is_some() {
+        return Err(eco_format!("pattern parameter is not supported with unit \"word\""));
+    }
+
+    let stripped = match direction {
+        ExtractDirection::First => trim_with_chars(string.0.as_str(), strip, true),
+        ExtractDirection::Last => trim_with_chars(string.0.as_str(), strip, false),
+    };
+
+    let source = if skip_whitespace {
+        match direction {
+            ExtractDirection::First => stripped.trim_start(),
+            ExtractDirection::Last => stripped.trim_end(),
+        }
+    } else {
+        stripped
+    };
+
+    let whitespace_only = skip_whitespace && !stripped.is_empty() && source.is_empty();
+    let strip_removed_all =
+        strip.is_some() && !string.0.is_empty() && stripped.is_empty();
+
+    let mut pattern_no_match = false;
+    let candidates: Vec<&str> = match unit {
+        SelectionUnit::Grapheme => {
+            let base: Vec<&str> = source.graphemes(true).collect();
+            if let Some(pattern_ref) = pattern.as_ref() {
+                let mut filtered = Vec::new();
+                for grapheme in base.iter().copied() {
+                    if matches_pattern(grapheme, pattern_ref.as_str())? {
+                        filtered.push(grapheme);
+                    }
+                }
+                if filtered.is_empty() && !base.is_empty() {
+                    pattern_no_match = true;
+                }
+                filtered
+            } else {
+                base
+            }
+        }
+        SelectionUnit::Word => collect_words(source),
+    };
+
+    if candidates.is_empty() {
+        if let Some(default) = default {
+            return Ok(Value::Str(default));
+        }
+
+        if safe {
+            return Ok(Value::None);
+        }
+
+        if pattern_no_match {
+            if let Some(pattern_ref) = pattern.as_ref() {
+                return Err(eco_format!(
+                    "no character matches pattern \"{}\"",
+                    pattern_ref.as_str()
+                ));
+            }
+        }
+
+        if whitespace_only {
+            return Err(eco_format!("string contains only whitespace"));
+        }
+
+        if strip_removed_all || string.is_empty() {
+            return Err(string_is_empty());
+        }
+
+        if matches!(unit, SelectionUnit::Word) {
+            return Err(string_contains_no_words());
+        }
+
+        if let Some(pattern_ref) = pattern.as_ref() {
+            return Err(eco_format!(
+                "no character matches pattern \"{}\"",
+                pattern_ref.as_str()
+            ));
+        }
+
+        return Err(string_is_empty());
+    }
+
+    let idx = index.unwrap_or(0);
+    if idx >= candidates.len() {
+        return Err(eco_format!(
+            "index {} out of bounds for string with {} characters",
+            idx,
+            candidates.len()
+        ));
+    }
+
+    if let Some(n) = count {
+        let slice: &[_] = match direction {
+            ExtractDirection::First => {
+                if idx + n > candidates.len() {
+                    return Err(eco_format!(
+                        "not enough characters (requested {}, but string only has {})",
+                        n,
+                        candidates.len() - idx
+                    ));
+                }
+                &candidates[idx..idx + n]
+            }
+            ExtractDirection::Last => {
+                let target = candidates.len() - 1 - idx;
+                if n > target + 1 {
+                    return Err(eco_format!(
+                        "not enough characters (requested {}, but string only has {})",
+                        n,
+                        target + 1
+                    ));
+                }
+                let start = target + 1 - n;
+                &candidates[start..=target]
+            }
+        };
+
+        let array = Array::from_iter(slice.iter().map(|seg| Value::Str((*seg).into())));
+        return Ok(Value::Array(array));
+    }
+
+    let result_str = match direction {
+        ExtractDirection::First => {
+            let available = candidates.len() - idx;
+            if repeat > available {
+                return Err(eco_format!(
+                    "not enough characters (requested {}, but string only has {})",
+                    repeat,
+                    available
+                ));
+            }
+            let slice = &candidates[idx..idx + repeat];
+            if repeat == 1 {
+                slice[0].into()
+            } else {
+                let mut result = EcoString::new();
+                for segment in slice {
+                    result.push_str(segment);
+                }
+                result.into()
+            }
+        }
+        ExtractDirection::Last => {
+            let target = candidates.len() - 1 - idx;
+            let available = target + 1;
+            if repeat > available {
+                return Err(eco_format!(
+                    "not enough characters (requested {}, but string only has {})",
+                    repeat,
+                    available
+                ));
+            }
+            let start = available - repeat;
+            let slice = &candidates[start..=target];
+            if repeat == 1 {
+                candidates[target].into()
+            } else {
+                let mut result = EcoString::new();
+                for segment in slice {
+                    result.push_str(segment);
+                }
+                result.into()
+            }
+        }
+    };
+
+    Ok(Value::Str(result_str))
+}
+
+#[derive(Clone, Copy, PartialEq, Eq)]
+enum SelectionUnit {
+    Grapheme,
+    Word,
+}
+
+fn selection_unit(unit: Option<&Str>) -> StrResult<SelectionUnit> {
+    match unit.map(|u| u.as_str()) {
+        None | Some("grapheme") => Ok(SelectionUnit::Grapheme),
+        Some("word") => Ok(SelectionUnit::Word),
+        Some(other) => Err(eco_format!("unknown unit \"{}\"", other)),
+    }
+}
+
+fn trim_with_chars<'a>(text: &'a str, strip: Option<&Str>, from_start: bool) -> &'a str {
+    match strip {
+        Some(chars) if !chars.is_empty() => {
+            let set = chars.as_str();
+            if from_start {
+                text.trim_start_matches(|ch| set.contains(ch))
+            } else {
+                text.trim_end_matches(|ch| set.contains(ch))
+            }
+        }
+        _ => text,
+    }
+}
+
+fn collect_words(text: &str) -> Vec<&str> {
+    text.split_word_bounds()
+        .filter(|segment| segment.chars().any(|ch| !ch.is_whitespace()))
+        .collect()
+}
+
+fn string_contains_no_words() -> EcoString {
+    eco_format!("string contains no words")
+}
+
+fn apply_case(value: Str, case: Option<&Str>) -> StrResult<Str> {
+    match case {
+        None => Ok(value),
+        Some(case) => {
+            let source = value.as_str();
+            let converted = match case.as_str() {
+                "upper" => source.to_uppercase(),
+                "lower" => source.to_lowercase(),
+                "title" => to_title_case(source),
+                other => return Err(eco_format!("unknown case option \"{}\"", other)),
+            };
+            Ok(converted.into())
+        }
+    }
+}
+
+fn apply_case_value(value: Value, case: Option<Str>) -> StrResult<Value> {
+    let Some(case) = case else {
+        return Ok(value);
+    };
+
+    match value {
+        Value::Str(str) => apply_case(str, Some(&case)).map(Value::Str),
+        Value::Array(array) => {
+            let mut transformed = Array::with_capacity(array.len());
+            for item in array {
+                match item {
+                    Value::Str(str) => {
+                        transformed.push(Value::Str(apply_case(str, Some(&case))?));
+                    }
+                    other => transformed.push(other),
+                }
+            }
+            Ok(Value::Array(transformed))
+        }
+        other => Ok(other),
+    }
+}
+
+fn validate_case(case: &Str) -> StrResult<()> {
+    match case.as_str() {
+        "upper" | "lower" | "title" => Ok(()),
+        other => Err(eco_format!("unknown case option \"{}\"", other)),
+    }
+}
+
+fn to_title_case(s: &str) -> String {
+    let mut chars = s.chars();
+    if let Some(first) = chars.next() {
+        let mut result = String::new();
+        result.extend(first.to_uppercase());
+        for ch in chars {
+            result.extend(ch.to_lowercase());
+        }
+        result
+    } else {
+        String::new()
+    }
+}
+
+fn matches_pattern(grapheme: &str, pattern: &str) -> StrResult<bool> {
+    let ch = match grapheme.chars().next() {
+        Some(c) => c,
+        None => return Ok(false),
+    };
+
+    Ok(match pattern {
+        "alpha" => ch.is_alphabetic(),
+        "numeric" => ch.is_numeric(),
+        "alphanumeric" => ch.is_alphanumeric(),
+        "uppercase" => ch.is_uppercase(),
+        "lowercase" => ch.is_lowercase(),
+        "whitespace" => ch.is_whitespace(),
+        _ => return Err(eco_format!("unknown pattern \"{}\"", pattern)),
+    })
+}
+
 impl Deref for Str {
     type Target = str;
 
